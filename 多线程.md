# 多线程

## 一、线程相关的术语

### 并发和并行

- 并发：两个或多个事件在`同一时间段内`发生，多个CPU同时执行多个任务；
- 并行：两个或多个事件在`同一时刻`发生，一个CPU（采用时间片）同时执行多个任务。

### 线程和进程

- 进程：指内存中运行的应用程序程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位，系统运行一个程序是一个进程从创建、运行到消亡的过程；

- 线程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程可以有多个线程；

  一个Java程序至少有三个线程：main主线程，gc垃圾回收线程，异常处理线程。

- 线程调度

  线程调度：分时调度和抢占式调度。Java的线程调度

  1. 同等优先级线程组成队列，使用时间片策略
  2. 对于不同优先级，高优先级抢占低优先级的调度

  线程优先级等级

  - MAX_PRIORITY：10
  - MIN_PRIORITY：1
  - NORM_PRIORITY：5

  方法

  - getPriority()：返回线程优先级
  - setPriority(int newPriority)：设置线程优先级

  说明

  1. 线程创建时继承父线程的优先级
  2. 低优先级只是获得调用的概率低，并不一定是在高优先级线程之后才被调用

## 二、实现多线程的方式

### 继承Thread

定义Thread子类，重写`run()`方法；创建Thread子类的实例，调用`start()`方法。

> 注意：
>
> 1. 不能使用run方法作为启动线程的方法，否则，依然也只是一个单线程。
> 2. 一个线程对象只能启动一次，即start一次。

Thread类：

- `public Thread()`
- `public Thread(String name)`
- `public Thread(Runnable target)`
- `public Thread(Runnable target， String name)`
- `public String getName()`
- `public String setName()`
- `public void start()`
- `public void run()`
- `public static void sleep(long millis)`
- `public static Thread currentThread()`
- `public void yield()`：释放当前线程的cpu执行权
- `public void join()`：在线程a中调用线程b的join，此时线程a就进入阻塞状态，直到线程b执行结束之后，a才会结束阻塞状态。
- `public void stop()`：强制结束当前线程，已过时。
- `public boolean isAlive()`：判断当前线程是否还存活

### 实现Runnable接口

定义Runnable接口的实现类，重写run方法；创建Runnable实现类的对象，传入Thread对象，调用Thread的start()方法。可以使用内部类和Lambda表达式优化代码

### 两种方式的对比

实现多线程，通常分成两类：继承Thread，实现Runnable。准确的讲，创建线程只有一个方式，即构造Thread类，而实现线程的执行单元有两种方式：

1. 实现Runnable接口的run方法，并把Runnable实例传给Thread类；
2. 重写Thread的run方法。

两种方式比较来看，实现Runnable的方式会更好：

1. 代码架构角度：Thread和Runable的职责是不同的。Thread负责的是管理线程方面的事情，比如新建，启动，停止等操作，而Runnable负责的是线程的具体执行内容。一般地，我们需要创建线程的目的是指定线程去做我们想做的事情，那么实现Runnable就会比较合理。
2. 线程新建的损耗：对于每一个直接new出来的Thread，os需要分配很多系统资源出来，而Runnable实例，是可以共用一个Thread的资源。实现Runnable方式更节省资源。
3. 扩展性：在Java中一个类是不能多继承，但可以多实现。一旦一个类继承Thread类，就不可以继承其他类，影响拓展性。而实现Runnable则不会有这样的影响。

## 三、启动线程

启动一个线程应该调用start()方法，而不是run()方法：

- start()：会请求os（start0方法）启动新线程。只能调用一次，否则抛异常；
- run()：此线程会执行线程任务，不是新的线程去执行。

## 四、停止线程

应该使用interrupt来通知线程停止，而不是使用stop强制线程停止。正确的停止线程，除了请求方发出停止通知，被停止方也要去检查是否线程是否停止，如果有子方法，也要让子方法把线程停止的通知传递出来或者恢复中断。在日常开发中，一定要使用一些可以响应中断的方法。线程在执行完任务或者发生异常并没有处理时会停止，并释放占用的资源。

### 最佳实践

需要在自定义的任务中编写响应可中断的代码逻辑，并在外部的特定时机发送可中断信号。优先选择传递中断，如果不想传递或无法传递，可以恢复中断。但不可以屏蔽中断。

不可以使用stop、suspend和resume方法停止线程：

- stop是不安全的，会释放所有的监视器，
- suspend和resume在停止时会持有锁，容易造成死锁。

不可以使用volatile + 标记位的方式停止线程：线程可能会在一直阻塞在某处，而一直不会去判断标记位，这样的情况下，想通过标记位让线程停止就无法实现。

### 相关函数

- public void interrupt()：停止调用此方法的线程对象，同时清除线程状态；
- public static boolean interrupted()：返回线程状态。这个线程是执行这行代码的线程；
- public boolean isInterrupted()：返回线程状态，不会清楚线程状态。

## 五、线程的状态

线程的6个状态

- ​	New
- Runnable：调用start之后，包含os中的ready和ruuning两种状态
- Blocked：有synchronized引起的阻塞
- Waiting
- Time Waiting
- Terminated

![image-20210110233345051](C:/Users/daffupman/AppData/Roaming/Typora/typora-user-images/image-20210110233345051.png)

阻塞的状态包括Blocked、Waiting和Timed_Waiting。

Thread和Object类中与线程相关的方法

- wait、notify、notifyAll

  - 作用：阻塞阶段：调用wait方法的对象，一定是先拥有monitor锁的，执行wait之后本线程进入阻塞阶段。直到下面的4种情况之一发生时，才会被唤醒：
    - 另一个线程调用这个对象的notify方法且刚好被唤醒的是本线程；
    - 另一个线程调用这个对象的notifyAll方法；
    - 过了wait(timeout)规定的超时时间；
    - 线程自身调用interrupt方法。
  - 唤醒阶段：使用notify、notifyAll可唤醒线程。
  - 遇到中断： 

- sleep

  - 作用：让线程在预期的时间执行，其他时候不要占用CPU资源；
  - sleep不会释放锁，包括synchronized和lock。与wait不同。
  - sleep方法响应中断：抛出InterruptException，并清除中断状态。
  - sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。

  > wait/notify、sleep异同？        
  >
  > - 相同：都会让线程进入阻塞状态，也都会响应中断。
  > - 不同：wait/notify需要在同步方法中使用（防止死锁），而sleep不需要；wait/notify会释放锁，而sleep不会；sleep可以指定时间，而wait不可以；wait/notify属于Object类，sleep属于Thread类。

- join

  - 作用：因为新线程加入了，所以需要等新线程执行完再执行。
  - join原理：
    - 源码
    - 分析
    - 等价

- yield

  - 作用：释放我的CPU时间片，但JVM不一定会把资源转让。
  - Thread.currentThread()
  - start、run
  - stop、suspend、resume

## 六、线程的属性

| 属性名称 | 用途                      |
| -------- | ------------------------- |
| id       | 每个线程的唯一标志        |
| name     | 线程名称                  |
| isDaemon | 是否是守护线程            |
| priority | 优先级。10个级别，默认5。 |

## 七、线程的未捕获UncaughtException如何处理

### 为什么需要UncaughtExceptionHandler？

- 主线程可以轻松发现异常，子线程却不行；
- 子线程异常无法用传统方法捕获；
- 不能直接捕获的后果，提高健壮性。

### 两种解决方案

- 手动在每个run方法里面捕获异常
- 使用UncaughtExceptionHandler 

## 八、线程的问题