# 并发工具

## 一、线程封闭ThreadLocal

ThreadLocal的使用场景：

1. 每个线程需要一个独享的对象（通常是工具类，典型的使用的类有SimpleDateFormat和Random）。每个Thread内有自己的实例副本，不共享。
2. 每个线程内需要保存全局变量（如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。

使用ThreadLocal的好处：

1. 保证线程安全
2. 不需要加锁，提高执行效率
3. 更高效地利用内存、节省开销
4. 免去传参的繁琐

主要方法

- T initialValue()：
  - 该方法会返回当前线程对应的初始值，这是一个延迟加载的方法，只有在调用get的时候，才会触发；
  - 当线程第一次使用get方法访问变量时，将调用此方法，除非线程先调用set方法，在这种情况下，不会为线程调用本initialValue方法；
  - 通常，每个线程最多调用一次此方法，但如果已经调用remove后，再调用get，则可以再次调用此方法；
  - 如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法重写initialValue方法，以便在后续使用中可以初始化副本对象；
- void set(T t)：为线程设置一个新值；
- T get()：
  - 获取这个线程对应的value，如果是首次调用get则会调用initialize来得到这个值；
  - 先获取当前线程的ThreadLocalMap，然后调用map.getEntry，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的value；
- void remove():
  - 删除对应这个线程的值

注意点

1. 内存泄漏：ThreadLocal#Entry定义了一对kv，其中k是弱引用，v是强引用。弱引用的特点是，如果这个对象只被弱引用关联，那么这个对象就可以被回收，即只要GC发现了这个弱引用就会回收。v是强引用导致了内存泄漏。正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收。如果线程线程复用，那么key对应的value就不会被回收，可能会发生OOM。要求在不使用的时候调用remove方法，删除对应的Entry对象，可以避免内存泄漏。
2. 共享对象：如果每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问的问题。
3. 优先使用框架的支持，比如在Spring中，框架自己维护了RequestContextHolder，那么就不需要自己去维护ThreadLocal，自己也可能忘记调用remove方法，造成内存泄漏。

## 二、Lock接口

锁是一种工具，用于控制对共享资源的访问。Lock和synchronized，都是常见的锁，都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。Lock并不是用来代替synchronized的而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的。

Lock接口最常见的实现类是ReentrantLock。一般，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也允许并发访问，如ReadWriteLock里的ReadLock。Lock具有可见性的保证。synchronized的问题：

- 效率低：锁的释放情况少，试图获得锁时不能设定超过、不能中断一个正在试图获取锁的线程。
- 不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（对象），可能是不够的。
- 无法知道是否成功获取到锁。

### Lock主要方法

- lock()：获取锁，如果锁被其他线程获取，则等待。Lock不会像synchronized一样在异常时自动释放锁。因此一定要在finally中释放锁。lock()方法不能被中断，这会带来很大的隐患，一旦陷入死锁，lock就会永久等待。
- tryLock()：尝试获取锁。如果当前锁没有背其他线程占用，则获取成功，则返回true，否则返回false，代表获取失败。可以根据是否能获取锁来决定后续程序的行为。该方法会立即返回，即使在拿不到锁时，不会一直等待。
- tryLock(long time, TimeUnit unit)：尝试获取锁，超过就放弃。
- lockInterruptibly()：上一个方法的无限等待版，在等待锁的过程中，线程可以被中断。

### 乐观锁和悲观锁

#### 互斥同步锁的劣势

1. 阻塞和唤醒有性能开销；
2. 永久阻塞：如果持有锁的线程被永久阻塞，如：无限循环，死锁等活跃性问题，那么等待该线程释放锁的那些线程就无法得到执行；
3. 优先级反转：低优先级的线程（可能会执行耗时的任务）持有锁的时候，高优先级线程只能等待；

#### 悲观锁

为了保证结果正确，每次修改数据时会锁住数据。Java中的synchronized和Lock相关类是悲观锁。适合并发写多的场景，适合临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋消耗，比如：

- 临界区有IO操作
- 临界区代码复杂或者循环量大
- 临界区竞争非常激烈

#### 乐观锁

为保证数据正确，采用数据比较的方式（而不是锁住数据）。一般会使用CAS算法实现乐观锁。适合并发读多的场景，不加锁，性能会大幅提高。

### 可重入锁和非可重入锁

以ReentrantLock为例，相关方法有：

- getHoldCount()
- isHeldByCurrentThread
- getQueueLength()

### 公平锁和非公平锁

公平指的是按照线程请求的顺序来分配锁；非公平是指不完全按照请求的顺序，在一定的情况下可以插队。非公平同样不提倡插队行为。锁的默认策略是非公平，非公平可以避免唤醒带来的空挡期，提高效率。但是对于tryLock方法，它是不遵守公平的规则的。

|        | 优势                                                     | 劣势                                                       |
| ------ | -------------------------------------------------------- | ---------------------------------------------------------- |
| 公平锁 | 各线程公平平等，每个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更小                                           |
| 不公平 | 更快，吞吐量更小                                         | 有可能产生线程饥饿，也就是某些在长时间内，始终得不到执行。 |

### 共享锁和排他锁

- 排他锁，又称独占锁、独享锁。
- 共享锁，又称读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获得共享锁，也可以查看但无法修改和删除数据。

共享锁和排他锁的典型是读写锁ReentrantReadWriteLock，读锁时共享锁，写锁时独享锁。在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，是没有线程安全问题的。在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率。

#### 读写锁的规则

- 多个线程只申请读锁，都可以申请到；
- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁；
- 如果有一个线程已经占用了写锁，则此时其他线程如果要申请读锁，则申请的线程会一直等待释放写锁；
- 总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。要么多读，要么一写。

#### 读锁和写锁的交互方式

#### 读锁插队策略

- 公平锁：不允许插队
- 非公平锁：
  - 写锁可以随时插队
  - 读锁仅在等待队列头节点不是获取写锁的线程的时候可以插队

#### 锁的升降级

ReentrantLock锁支持降级，不支持升级。不支持升级的原因是避免死锁。

### 自旋锁和阻塞锁

自旋锁：阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的话费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就释放锁。而为了让当前线程稍等一下，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒。如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋的时间的增长，开销也是线性增长的。JUC中的atmoic包下的类大多数都是自旋锁实现的。

### 可中断锁

synchronized是不可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断。如果某一线程A正在执行锁中的代码，另一个线程B正在等待，可能由于等待时间过长，线程B不想等待了，想先处理B，我们可以中断它，这种就是可中断锁。

### 锁优化

Java虚拟机对锁的优化

- 自旋锁和自适应
- 锁消除
- 锁粗化

使用上的优化

- 缩小同步代码块，尽量不要锁住方法
- 减少锁的次数
- 避免人为制造热点 
- 锁中尽量不要再包含锁
- 选择合适的锁类型或合适的工具类